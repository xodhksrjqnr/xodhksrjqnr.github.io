## Docker overview [#](https://docs.docker.com/get-started/overview/)

Docker는 애플리케이션을 개발, 전송 및 실행하기 위한 개방형 플랫폼이다. Docker를 사용하면 애플리케이션을 인프라에서 분리하여 소프트웨어를 신속하게 제공할 수 있고, 애플리케이션을 관리하는 것과 동일한 방식으로 인프라를 관리할 수 있다. 코드를 신속하게 전송, 테스트 및 배포하는 Docker의 방법론을 활용하면 코드를 작성하고 실제 환경에서 실행하는 데 걸리는 시간을 크게 줄일 수 있다.

## The Docker Platform

Docker는 컨테이너라고 하는 느슨하게 격리된 환경에서 응용 프로그램을 패키지화하고 실행할 수 있는 기능을 제공한다. 격리 및 보안을 통해 지정된 호스트에서 여러 컨테이너를 동시에 실행할 수 있다. 컨테이너는 가볍고 애플리케이션을 실행하는 데 필요한 모든 것을 포함하므로 호스트에 현재 설치된 것에 의존할 필요가 없다. 작업하는 동안 컨테이너를 쉽게 공유할 수 있으며 공유하는 모든 사용자가 동일한 방식으로 작동하는 동일한 컨테이너를 사용하는 것을 보장한다.

Docker는 컨테이너의 라이프사이클을 관리하기 위한 툴링과 플랫폼을 제공한다:

- 컨테이너를 사용하여 응용프로그램 및 지원 구성요소를 개발한다.
- 컨테이너는 응용프로그램을 배포하고 테스트하기 위한 단위가 된다.
- 준비가 되면 애플리케이션을 컨테이너 또는 오케스트레이션된 서비스로 프로덕션 환경에 배포한다. 이는 운영 환경이 로컬 데이터 센터, 클라우드 공급자 또는 둘의 하이브리드인지에 관계없이 동일하다.

## What can I use Docker for?

### 애플리케이션의 빠르고 일관된 제공

Docker는 개발자들이 애플리케이션과 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화된 환경에서 작업할 수 있도록 함으로써 개발 라이프사이클을 간소화한다. 컨테이너는 지속적인 통합 및 지속적인 제공(CI/CD) 워크플로우에 적합하다.

다음 시나리오의 예를 생각해 보자:

- 개발자는 로컬에서 코드를 작성하고 Docker 컨테이너를 사용하여 동료와 작업을 공유한다.
- Docker를 사용하여 응용 프로그램을 테스트 환경으로 밀어넣고 자동 및 수동 테스트를 실행한다.
- 개발자는 버그를 발견하면 개발 환경에서 버그를 수정하고 테스트 및 검증을 위해 테스트 환경에 재배치할 수 있다.
- 테스트가 완료되면 업데이트된 이미지를 프로덕션 환경에 푸시하는 것만으로 고객에게 수정 사항을 전달할 수 있다.

### 신속한 구축 및 확장

Docker의 컨테이너 기반 플랫폼을 통해 이동성이 높은 워크로드를 처리할 수 있다. Docker 컨테이너는 개발자의 로컬 노트북, 데이터 센터의 물리적 또는 가상 시스템, 클라우드 제공자 또는 혼합 환경에서 실행될 수 있다.

또한 Docker의 휴대성과 경량 특성을 통해 거의 실시간으로 워크로드를 동적으로 관리하고 비즈니스 요구에 따라 애플리케이션과 서비스를 확장하거나 해체할 수 있다.

### 동일한 하드웨어에서 더 많은 워크로드 실행

Docker는 가볍고 빠르다. 하이퍼바이저 기반 가상 머신을 대체할 수 있는 실행 가능하고 비용 효율적인 대안을 제공하므로 비즈니스 목표를 달성하기 위해 서버 용량을 더 많이 사용할 수 있다. Docker는 고밀도 환경과 적은 리소스로 더 많은 작업을 수행해야 하는 중소규모 구현에 적합하다.

## Docker architecture

Docker는 클라이언트-서버 아키텍처를 사용한다. Docker 클라이언트는 Docker 컨테이너를 구축, 실행 및 배포하는 작업을 하는 Docker 데몬과 대화한다. Docker 클라이언트와 데몬을 동일한 시스템에서 실행하거나 Docker 클라이언트를 원격 Docker 데몬에 연결할 수 있다. Docker 클라이언트와 데몬은 UNIX 소켓 또는 네트워크 인터페이스를 통해 REST API를 사용하여 통신한다. 또다른 Docker 컨테이너인 Docker Compose를 사용하면 컨테이너 집합으로 구성된 응용 프로그램을 사용할 수 있다.

![](https://docs.docker.com/assets/images/architecture.svg)

### The Docker daemon

Docker 데몬(`Dockerd`)은 Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크 및 볼륨과 같은 Docker 개체를 관리한다. 또한 데몬은 다른 데몬과 통신하여 Docker 서비스를 관리할 수 있다.

### The Docker client

Docker 클라이언트(`Docker`)는 많은 Docker 사용자가 Docker와 상호 작용하는 기본 방법이다. `docker run`과 같은 명령을 사용하면 클라이언트는 이러한 명령을 Dockerd로 전송하여 이 명령을 수행한다. Docker 명령은 Docker API를 사용합니다. Docker 클라이언트는 둘 이상의 데몬과 통신할 수 있다.

### Docker Desktop

Docker Desktop은 Mac, Windows 또는 Linux 환경을 위한 설치하기 쉬운 응용 프로그램으로, 컨테이너형 응용 프로그램 및 마이크로 서비스를 구축하고 공유할 수 있다. Docker Desktop에는 Docker 데몬(`Dockerd`), Docker 클라이언트(`Docker`), Docker Compose, Docker Content Trust, Kubernetes 및 Credential Helper가 포함된다. 자세한 내용은 [Docker Desktop](https://docs.docker.com/desktop/)을 참조하자.

### Docker registries

Docker 레지스트리는 Docker 이미지를 저장한다. Docker Hub는 누구나 사용할 수 있는 공용 레지스트리이며 Docker는 기본적으로 Docker Hub에서 이미지를 찾도록 구성되어 있다. 개인 레지스트리를 실행할 수도 있다.

`docker pull` 또는 `docker run` 명령을 사용하면 구성된 레지스트리에서 필요한 이미지를 가져온다. `docker push` 명령을 사용하면 이미지가 구성된 레지스트리로 푸시된다.

### Docker objects

Docker를 사용하면 이미지, 컨테이너, 네트워크, 볼륨, 플러그인 및 기타 개체를 생성하고 사용할 수 있다. 이 섹션에서는 이러한 개체 중 일부에 대해 간략하게 설명한다.

### Images

이미지는 Docker 컨테이너를 만드는 방법이 설명된 읽기 전용 템플릿이다. 종종 이미지는 추가 사용자 지정과 함께 다른 이미지를 기반으로 한다. 예를 들어 Ubuntu 이미지를 기반으로 이미지를 구축하지만 Apache 웹 서버와 응용 프로그램은 물론 응용 프로그램을 실행하는 데 필요한 구성 상세 내역을 설치할 수 있다.

사용자가 직접 이미지를 만들거나 다른 사용자가 생성하여 레지스트리에 게시한 이미지만 사용할 수 있다. 고유한 이미지를 빌드하려면 이미지를 만들고 실행하는 데 필요한 단계를 정의하기 위한 간단한 구문을 사용하여 Dockerfile을 만든다. Dockerfile의 각 명령은 이미지에 레이어를 생성한다. Dockerfile을 변경하고 이미지를 재구성하면 변경된 계층만 재구성된다. 이는 다른 가상화 기술과 비교할 때 이미지를 매우 가볍고, 작고, 빠르게 만드는 부분이다.

### Containers

컨테이너는 이미지의 실행 가능한 인스턴스이다. Docker API 또는 CLI를 사용하여 컨테이너를 생성, 시작, 중지, 이동 또는 삭제할 수 있다. 컨테이너를 하나 이상의 네트워크에 연결하거나, 스토리지를 연결하거나, 컨테이너의 현재 상태를 기반으로 새 이미지를 생성할 수 있다.

기본적으로 컨테이너는 다른 컨테이너 및 해당 호스트 시스템과 비교적 잘 분리된다. 컨테이너의 네트워크, 스토리지 또는 기타 기본 하위 시스템이 다른 컨테이너 또는 호스트 시스템과 얼마나 격리되어 있는지 제어할 수 있다.

컨테이너는 컨테이너를 만들거나 시작할 때 컨테이너에 제공하는 구성 옵션뿐만 아니라 이미지에 의해 정의된다. 컨테이너가 제거되면 영구 저장소에 저장되지 않은 상태의 변경 내용이 모두 사라진다.

`docker run` 명령어 예제

다음 명령은 `ubuntu` 컨테이너를 실행하고 로컬 명령줄 세션에 대화형으로 연결하고 `/bin/bash`를 실행한다.

```
docker run -i -t ubuntu /bin/bash
```

이 명령을 실행하면 다음과 같은 상황이 발생한다(기본 레지스트리 구성을 사용하는 경우):

1. 로컬에 `ubuntu` 이미지가 없으면 `docker pull ubuntu`를 수동으로 실행한 것처럼 Docker가 구성된 레지스트리에서 이미지를 꺼낸다.
2. `docker container create` 명령을 수동으로 실행한 것처럼 Docker가 새 컨테이너를 만든다.
3. Docker는 컨테이너에 읽기-쓰기 파일 시스템을 최종 계층으로 할당한다. 이렇게 하면 실행 중인 컨테이너가 로컬 파일 시스템에서 파일 및 디렉터리를 만들거나 수정할 수 있다.
4. 네트워킹 옵션을 지정하지 않았으므로 Docker는 컨테이너를 기본 네트워크에 연결하는 네트워크 인터페이스를 만든다. 여기에는 컨테이너에 IP 주소를 할당하는 작업이 포함된다. 기본적으로 컨테이너는 호스트 시스템의 네트워크 연결을 사용하여 외부 네트워크에 연결할 수 있다.
5. Docker가 컨테이너를 시작하고 `/bin/bash`를 실행한다. 컨테이너가 대화형으로 실행되고 터미널에 연결되어 있기 때문에(`-i` 및 `-t` 플래그 때문에) 출력이 터미널에 기록되는 동안 키보드를 사용하여 입력을 제공할 수 있다.
6. `exit`를 입력하여 `/bin/bash` 명령을 종료하면 컨테이너가 중지되지만 제거되지는 않는다. 다시 시작하거나 제거할 수 있다.

## The underlying technology

Docker는 Go 프로그래밍 언어로 작성되며 Linux 커널의 여러 기능을 활용하여 기능을 제공한다. Docker는 네임스페이스라는 기술을 사용하여 컨테이너라는 격리된 작업 공간을 제공한다. 컨테이너를 실행할 때 Docker는 해당 컨테이너의 네임스페이스 집합을 작성한다.

이러한 네임스페이스는 격리 계층을 제공한다. 컨테이너의 각 측면은 별도의 네임스페이스에서 실행되며 액세스는 해당 네임스페이스로 제한된다.