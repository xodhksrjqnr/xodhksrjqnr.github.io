# 추상 클래스와 인터페이스

공통점은 다음과 같다.

- `인스턴스 생성이 불가능`
- `상속받은 추상 메서드를 반드시 구현`

차이점은 다음과 같다.

추상 클래스는 `extends` 키워드를 사용하여 상속하고, `다중 상속이 불가능`하다. `추상 메서드 포함이 가능`한 것을 제외하면 일반 클래스와 같다.

인터페이스는 `implements` 키워드를 사용하여 상속하고, `다중 상속이 가능`하다. `java 8부터 디폴트, 정적 메서드 구현이 가능`하며, `상수` 및 `public 접근 제어자`만 사용 가능하다.

***

# JPA(Java Persistence API)

자바 진영의 ORM 기술 표준으로 다음과 같은 특징이 있다.

- 애플리케이션과 JDBC 사이에서 동작
- 내부적으로 JDBC API를 활용하여 SQL 생성 및 DB와 통신
- 객체를 자동으로 매핑

위와 같은 이유로 다음 이점을 얻는다.

- SQL 중심적인 개발에서 객체 중심의 개발이 가능
- 생산성 증가(메서드를 통한 데이터 처리)
- 유지보수 효율 증가(필드 추가 시 entity 객체에 해당 요소만 추가)
- Object와 RDB 간의 패러다임 불일치 해결(연관 관계 저장, 객체 상속 등)
- 성능 최적화

***

# ORM(Object-Relational Mapping)

객체와 관계형 DB의 데이터를 자동으로 매핑해주는 것

***

# Generics(제네릭스)

`다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스`에 `컴파일`할 때 `타입 체크`를 해주는 기능

다음의 이점이 있다.

- 타입 오류 시 `컴파일 단계`에서 확인이 가능해 `타입의 안정성을 제공`
- `타입 체크`와 `형변환`을 `생략`할 수 있어 `코드 간결성` 확보

***

# Boxing(박싱)과 Unboxing(언박싱)

`원시 타입`은 `int`, `char`, `byte`, `short`, `float`, `double`, `long`, `boolean`이며, stack 영역에 저장되고 null값을 가질 수 없으며 `==` 연산자로 값 비교한다.

`참조 타입`은 `wrapper class`(`Integer`, `Character`, `Byte`, `Short`, `Float`, `Double`, `Long`, `Boolean`)이며, stack 영역에 주소가 저장되고 heap 영역에서 값을 참조해 오며 null값을 가질 수 있고 `equals()`를 이용해 값을 비교한다.

- `Boxing(박싱)`은 원시 타입을 참조 타입으로 변환하는 것
- `Unboxing(언박싱)`은 참조 타입을 원시 타입으로 변환하는 것

jdk 1.5부터 `auto Boxing`과 `auto Unboxing`이 추가

원시 타입에 비해 참조 타입 처리가 느리기 때문에 참조 타입은 사용에 있어 적절한 지(null이 필요한 경우 등) 고민해야 한다.

***

