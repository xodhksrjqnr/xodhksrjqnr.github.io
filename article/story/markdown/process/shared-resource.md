# 공유 자원과 임계구역

협업에서 하나뿐인 도구를 모두가 사용하기 원하는 겨우 다른 사람이 사용이 끝나길 하염없이 기다리게 될 수 있다. 프로세스 간의 공유된 자원을 사용할 때도 이와 같은 문제가 발생할 수 있다. 이 파트에선 이런 자원에 대한 접근과 문제 해결을 위해 고려해야 할 점에 대해 알아보자.

## 공유 자원(shared resource)의 접근

공유 자원이란 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 의미한다. 공용으로 사용되기 때문에 누가, 언제 데이터에 접근하여 작업을 수행하냐에 따라 그 결과가 달라진다. 따라서 접근 순서를 정하여 예상치 못한 문제를 방지해야 한다. 간단한 예제를 통해 발생할 수 있는 문제를 확인해 보자.

### 은행 예금 시나리오

해당 시나리오는 `프로세스 A`와 `프로세스 B`가 각각 예금 조회와 예금 예치를 진행하는 과정이다. 처음 예금 액수는 만원이며 값은 전역 변수에 저장된다고 가정하자.

- 프로세스 A : 예금 확인 (10,000원)
- 프로세스 B : 예금 확인 (10,000원)
- 프로세스 B : 예금 저장 (+10,000원)
- 프로세스 B : 예금 확인 (20,000원)
- 프로세스 A : 예금 저장 (+20,000원)
- 프로세스 A : 예금 확인 (?원)

위 과정에서 최종 예금 금액은 4만원이 되어야 한다. 하지만 전역 변수에 저장된 값은 3만원이다. 프로세스 A의 결과를 마지막으로 전역 변수가 초기화 되었기 때문이다. 이처럼 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 `경쟁 조건(race condition)이 발생했다`고 하며, 공유 자원 접근 순서에 따라 실행 결과가 달라진다.

## 임계구역(critical section)

`공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역`을 `임계구역`이라고 한다. 은행 예금 시나리오에선 예금 저장 부분이 임계구역에 해당한다. 임계구역에선 프로세스들의 동시 작업이 불가능해지며 임계구역에서의 작업이 끝날 때까지 다른 프로세스들이 대기해야 한다. 임계구역과 관련된 전통적인 문제로 `생산자-소비자 문제`가 있다. 이에 대한 설명은 따로 진행하지 않기 때문에 검색을 통해 알아보자.

하드웨어 자원을 사용할 때도 임계구역 관련 문제가 발생할 수 있다. 만약 프린트 과정에서 순서에 상관없이 출력하게 된다면 출력물은 뒤죽박죽 섞여버린 결과물이 나오게 될 것이다. 물론 모든 공유 자원에서 문제가 발생하는 것은 아니다. 우리가 집중해야 할 문제가 되는 공유 자원은 `프로세스 실행 상황에서 공유가 불가능한 자원`이다.

그렇다면 임계구역에서 발생하는 문제를 해결하기 위한 조건을 알아보자.

- `상호 배제(mutex : mutual exclusion)` : 임계구역을 점유하는 프로세스가 존재하면 다른 프로세스는 임계구역에 진입할 수 없다. 즉, 한 번에 하나의 프로세스만 임계구역에 진입할 수 있다.
- `한정 대기(bounded waiting)` : 어떤 프로세스도 무한 대기(infinite postpone)해선 안 된다. 즉, 특정 프로세스가 임계구역에 진입하지 못하면 안 된다.
- `진행의 융통성(progress flexibility)` : 임계구역을 점유한 프로세스가 존재하지 않는다면 어떤 프로세스든 해당 임계구역에 진입할 수 있다. 이미 프로세스가 임계구역을 진입 후 나왔다고 해도 임계구역을 다시 진입할 필요가 있고 임계구역에 진입한 다른 프로세스가 없다면 언제든 진입할 수 있어야 한다. 한 프로세스가 다른 프로세스의 진행을 방해해선 안 된다는 것을 의미한다.

## 임계구역 해결 방법

### Lock을 이용한 방법

가장 단순한 방법으로 lock을 이용하는 것이다. 임계구역을 선점하는 프로세스는 임계구역에 진입하기 전에 lock을 걸고 사용이 끝난 뒤에 lock을 해제한다. lock이 걸린 상태에선 다른 프로세스가 임계구역에 진입할 수 없게 된다. 다음의 간단한 코드를 보자.

```java
while(lock == ture);
lock = true;
//임계구역
lock = false;
```

하지만 해당 방법에는 다음과 같은 많은 문제점이 존재한다.

- 임계구역을 진입하기 위해 대기하는 프로세스들은 바쁜 대기 상태로 자원 낭비가 심하다.
- `상호 배제`를 보장하지 못한다.

`상호 배제` 예외 시나리오를 생각해보자. lock이 false로 초기화된 경우 프로세스 A가 while문을 벗어나게 된다. 만약 이때 타임아웃(할당된 CPU 시간 종료)이 되고 프로세스 B가 CPU를 할당받게 되면 lock은 false인 상태이므로 프로세스 B도 while 문을 벗어나게 된다. 이 경우 두 프로세스 모두 임계구역에 진입하게 된다.

좀 더 보완된 형태로 두 개의 lock을 사용해보자.

```java
//프로세스 A
lock1 = true;
while(lock2 == ture);
//임계구역
lock1 = false;

//프로세스 B
lock2 = true;
while(lock1 == ture);
//임계구역
lock2 = false;
```

먼저 lock을 설정하고 반복문에서 서로의 lock이 풀릴 때까지 대기하게 되는 방식이다. 이로써 `상호 배제`가 보장되지만 아직도 문제가 발생한다.

- 무한 대기가 발생할 수 있어 `한정 대기`가 보장되지 못한다. 즉, 서로의 lock이 풀리길 기다리며 교착 상태(deadlock)에 빠지게 된다.
- 확장성 문제가 발생한다. 임계구역에 진입하려는 프로세스가 늘어날수록 lock의 개수가 늘어나 검사해야 할 lock의 개수가 많아져 비효율적이다.

위 문제점을 보완하는 또 다른 코드를 살펴보자.

```java
//프로세스 A
while(lock == 2);
//임계구역
lock = 2;

//프로세스 B
while(lock == 1);
//임계구역
lock = 1;
```

이번엔 lock을 true, false가 아닌 번호로 구분하는 방식으로 작업 종료 후에 서로에게 차례를 넘기게 된다. `상호 배제`와 `한정 대기`를 보장하지만 한 프로세스가 연속으로 임계구역에 진입이 불가능하다. 즉, 프로세스의 진행이 다른 프로세스로 인해 방해받는 경직된 동기화(lockstep synchronization) 현상이 발생하며 `진행의 융통성 조건`을 보장하지 못한다.

> lock 방식에서 하드웨어적인 방법을 이용해 문제를 해결할 수도 있다. 문제가 되는 while문과 lock 초기화하는 명령을 하드웨어적으로 동시에 실행하게 보장함으로써 타임아웃으로 인해 상호 배제가 보장되지 않는 것을 방지할 수 있다. 하지만 이 방법 역시 바쁜 대기를 수행하기 때문에 자원 낭비가 발생한다.

### 피터슨 알고리즘

turn이라는 변수를 추가적으로 사용해 임계구역 3가지 조건을 해결한 방식이다. turn 변수를 초기화함으로써 상대에게 차례를 양보하며 임계구역을 나오는 프로세스는 lock을 초기화함으로써 다른 프로세스가 반복문을 탈출하도록 한다. 하지만 이 방식은 2개의 프로세스만 사용 가능하다는 한계가 있다.

```java
//turn의 초기값은 1
//프로세스 A
lock1 = true;
turn = 2;
while(lock2 == true && turn == 2);
//임계구역
lock1 = false;

//프로세스 B
lock2 = true;
turn = 1;
while(lock1 == true && turn == 1);
//임계구역
lock2 = false;
```

### 데커 알고리즘

lock과 turn을 이용한 방식으로 임계구역 3가지 조건을 해결한 방식이다. 하드웨어의 도움 없이도 임계구역 문제를 해결할 수 있다는 특징이 있지만 복잡하다는 단점이 있다.

```java
//turn의 초기값은 1
//프로세스 A
lock1 = true;
while(lock2 == ture) {
    if (turn == 2) {
        lock1 = false;
        while(turn == 2);
        lock1 = true;
    }
}
//임계구역
turn = 2;
lock1 = false;

//프로세스 B
lock2 = true;
while(lock1 == ture) {
    if (turn == 1) {
        lock2 = false;
        while(turn == 1);
        lock2 = true;
    }
}
//임계구역
turn = 1;
lock2 = false;
```

### 세마포어(semaphore)

앞서 나온 알고리즘들의 문제점들(바쁜 대기로 인한 자원 낭비, 복잡한 알고리즘) 해결하기 위해 등장한 알고리즘이다. 프로세스는 임계구역에 진입하기 전 스위치의 값을 1 내린다. 다음 프로세스는 스위치의 값이 0보다 크면 마찬가지로 1을 줄이고 진입, 0이면 0보다 커질 때까지 대기한다. 이때 바쁜 대기를 하지 않고 세마포어 큐에 저장되어 있다가 임계구역을 나온 프로세스가 wake_up 동기화 신호를 보낼 때 임계구역에 진입하게 된다.

```java
Semaphore(n); //사용할 공유 자원 수(RS)
P(); // 잠금 수행, 0보다 크면 RS 1 감소, 0이면 0보다 커질 때까지 세마포어 큐에서 대기
//임계구역
V(); // 잠금 해제와 동기화 수행, RS 1 증가, 대기 중인 프로세스에 wake_up 신호 전달
```

매우 간단해진 형태의 코드이며 P()와 V()의 경우 내부 코드의 분리 실행이 아닌 동시 실행을 보장해야 한다.

### 모니터(monitor)

세마포어의 경우에도 사용자의 실수로 다음과 같은 문제가 발생할 수 있다.

- 임계구역 전후로 세마포어를 실수로 사용하지 않은 경우
- 임계구역 전후로 P()만 사용한 경우
- P()와 V()의 순서가 바뀐 경우

3가지 경우 모두 휴먼 에러로 인해 발생하는 문제이다. 따라서 인터페이스를 이용해 추상화하여 내부 로직을 숨기고 사용자는 원하는 결과만을 제공받는 것이 더욱 안정성이 높다. 모니터는 이런 점을 반영하여 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만을 제공한다.

- 임계구역으로 지정된 변수나 자원에 접근하기 위해 프로세스는 모니터에 작업 요청
- 모니터는 요청 받은 작업을 모니터 큐에 저장한 후 순서대로 처리 후 결과 반환

모니터는 임계구역 보호와 동기화를 위해 내부적으로 상태 변수를 사용하며, 상태 변수에는 wait()과 signal() 기능이 있다.

- wait() : 모니터 큐에서 자신의 차례가 올 때까지 기다린다. (= 세마포어 P())
- signal() : 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘긴다. (= 세마포어 V())

# 참고자료

- [쉽게 배우는 운영체제](https://www.yes24.com/Product/Goods/62054527)